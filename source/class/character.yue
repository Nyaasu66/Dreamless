import "class.animation" as Animation
import "vector"

local _lC = -- Cache
    "math.pi / 6": math.pi / 6
    "math.pi / 3": math.pi / 3
    "math.pi * (2 / 3)": math.pi * (2 / 3)
    "math.pi * (5 / 6)": math.pi * (5 / 6)

class Character extends Animation
    new: (animation_path, world, spawn_x = 0, spawn_y = 0, speed = 10, colliable_width = 0, colliable_height = 0, controller = Input) =>
        super animation_path
        assert @descriptor.states.move_up and @descriptor.states.move_down and @descriptor.states.move_left and @descriptor.states.move_right, "Invalid Character Sprite"
        @pause!
        if colliable_width <= 0 then colliable_width = @getFrameWidth!
        if colliable_height <= 0 then colliable_height = @getFrameHeight!
        @world = world
        @x = spawn_x
        @y = spawn_y
        @speed = speed
        @controller = index#: controller
        @world::add self, @x, @y, colliable_width, colliable_height
        @velocity = {0, 0}
    setController: (controller) =>
        @controller = index#: controller
    update: (dt) =>
        ix, iy = @controller::get "move"
        if ix != 0 or iy != 0
            @unpause!
            @velocity.x = ix * dt * @speed
            @velocity.y = iy * dt * @speed
            irad, ilen = vector.toPolar ix, iy
            @setSpeedMultiplier ilen
            if ix == 0
                if iy > 0
                    if @currentState != "move_up" then @setState "move_up"
                elseif @currentState != "move_down"
                    @setState "move_down"
            elseif iy == 0
                if ix > 0
                    if @currentState != "move_right" then @setState "move_right"
                elseif @currentState != "move_left"
                    @setState "move_left"
            elseif ix > 0 and iy > 0 -- First Quadrant
                if irad < _lC["math.pi / 6"] and @currentState != "move_right"
                    @setState "move_right"
                elseif irad > _lC["math.pi / 3"] and @currentState != "move_up"
                    @setState "move_up"
                elseif @currentState != "move_right" and @currentState != "move_up"
                    @setState ({"move_right", "move_up"})[math.random 1, 2]
            elseif ix < 0 and iy > 0 -- Second Quadrant
                if irad < _lC["math.pi * (2 / 3)"] and @currentState != "move_up"
                    @setState "move_up"
                elseif irad > _lC["math.pi * (5 / 6)"] and @currentState != "move_left"
                    @setState "move_left"
                elseif @currentState != "move_left" and @currentState != "move_up"
                    @setState ({"move_left", "move_up"})[math.random 1, 2]
            elseif ix < 0 and iy < 0 -- Third Quadrant
                if irad < -_lC["math.pi * (5 / 6)"] and @currentState != "move_left"
                    @setState "move_left"
                elseif irad > -_lC["math.pi * (2 / 3)"] and @currentState != "move_down"
                    @setState "move_down"
                elseif @currentState != "move_down" and @currentState != "move_left"
                    @setState ({"move_down", "move_left"})[math.random 1, 2]
            else -- Fourth Quadrant
                if irad < -_lC["math.pi / 3"] and @currentState != "move_down"
                    @setState "move_down"
                elseif irad > -_lC["math.pi / 6"] and @currentState != "move_right"
                    @setState "move_right"
                elseif @currentState != "move_right" and @currentState != "move_down"
                    @setState ({"move_down", "move_right"})[math.random 1, 2]
        else
            @pause!
            @setCurrentFrame 1
            @velocity.x, @velocity.y = 0, 0
        @x, @y = @world::move self, @x + @velocity.x, @y + @velocity.y
        super dt
